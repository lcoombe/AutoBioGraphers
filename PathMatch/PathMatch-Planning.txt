Path Match Script Sketch

GIVEN PARAMETERS:
m: max number of indels allowed in G0'
G: Input reference graph
G0: Input query graph

REQUIRED HELPER FUNCTIONS:

//Scoring the alignment between two graphs G0 and G0'
def ScoreAlignment(G0, G0'): 
- For each vertex in G0', find the vertex correspondance in V0 (if exists)
- For each vertex correspondance, add to the score
- For each vertex in V0 that wasn't in a correspondance (as above), penalize by delta.
- For each pair of associations (vi, vij), (vk, vkl) (such that vi and vj are in V0, and their corresponding vertices vij, vkl are in V0'):
	- If there is a (vi, vk) edge in G0:
		- Find the path length between vij and vkl in G0'
		- Penalize the score by -(path length-1)*delta


def isValidSolution(V0+, W'):
	For each pair of  vertices (vi, vk) in V0+:
		if (vi, vk) is an edge in E0:
			vij = corresponding vertex of vi in W'
			vkl = corresponding vertex of vk in W'
			(vij, vkl) must be an edge in E'

Class: Small class to represent the 'Tree' structure required for keeping track of the subgraphs already tested?
- with functions to test if a path is already in the graph, add to the tree?

MAIN: 

//Load in Query Graph G0


//Load in Reference Graph G


//Load in correspondances between vertices in G and G0
- for each V0, there is a set of correspondances, and a score
- Possible format: Dictionary, where key is the V0, and value is the correspondance (small class)
   * Perhaps create small class representing the 'corresponding vertex'
   * Fields in the class: name, score, vertex corresponds to


//Make G' --> will be used when enumerating solution graphs G0'
V' = Union of all corresponding vertices (from dictionary structure)
for each pair of corresponding vertices vij and vkl:
	If the vertices are not associated with the same vi, add edge (vij, vkl) to E' if (vi, vk) have edge in G0, and length of shortest path from vij to vkl in G is at most m+1

def GraphMatch(W, W'):

	With the loop, we are doing this:
	Enumerate all connected induced subgraphs of G0
	(Induced means that we pick the vertices, and a pair of vertices are connected in the subgraph if they have an edge in G0)
	- Each enumeration is a way to get V0+ (The vertices in G0 that have an association in G0')
	- To avoid enumerating graphs multiple times, represent connected induced subgraph as a path in a tree where the vertices are in sorted order in the tree T, last vertex marked

	//W: Set of vertices in V0+ currently
	//W': Set of vertices corresponding to V0+ vertices
		for each vertex vi in V0, but not already in W:
			If the induced subgraph by adding vi to W is connected, and not already found (in T):
				V0+ = Union of W and vi (that set of vertices)
				for each vertex vij in the correspondance list of vi:
					Run subroutine 'isValidSolution(V0+, W' union vij)'
					if valid solution:
						Use ScoreAlignment subroutine to find the alignment score
						record the score (Perhaps keep top 5 or something?)
						GraphMatch(W union {vi}, W' union {vij})
				add the W union {Vi} subgraph to T


